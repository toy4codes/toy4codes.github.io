---
layout: post
title:  "Git"
date:   2017-06-15 12:00:00
categories: git
---

# What is version control?

The VCSs solve one of the most common problems of software development: the fear for changing the software. A VCS will help you to get rid of being scared about changing your code.

# What is Git?

Git is a distributed version control system (DVCS), also known as decentralized. This means that every developer has a full copy of the repository.

# Install and Config Git

### Installing on Linux

```
sudo apt-get update
sudo apt-get install git
```

### Git Configuration

Git comes with a tool called git config that lets you get and set configuration variables that control all aspects of how Git looks and operates. These variables can be stored in three different places:

1. /etc/gitconfig file: Contains values for every user on the system and all their repositories. If you pass the option --system to git config, it reads and writes from this file specifically.

2. ~/.gitconfig or ~/.config/git/config file: Specific to your user. You can make Git read and write to this file specifically by passing the --global option.

3. config file in the Git directory (that is, .git/config) of whatever repository you’re currently using: Specific to that single repository.

Each level overrides values in the previous level, so values in .git/config trump those in /etc/gitconfig.

### Your Identity

```
git config --global user.name "John Doe"
git config --global user.email johndoe@example.com
```

you need to do this only once if you pass the --global option, because then Git will always use that information for anything you do on that system. If you want to override this with a different name or email address for specific projects, you can run the command without the --global option when you’re in that project.

### Checking Your Settings

```
git config --list
git config user.name
```

### Getting Help

```
git [verb] --help
```

# Git Usage

### Creating a repository

```
git init
```

### Checking status

```
git status
```

### Staging

Files are added to the index. The Git index is where the data that is going to be saved in the commit is stored temporarily, until the commit is done.

```
git add
```

### Commits

A commit is a full snapshot of the repository, that is saved in the database.

```
git commit -m "comment"
```

### Hash

Git identifies each commit uniquely using SHA1 hash function, based on the contents of the committed files. So, each commit is identified with a 40 character-long hexadecimal string, like the following.

```
de5aeb426b3773ee3f1f25a85f471750d127edfe
```

Take into account that the commit message, commit date, or any other variable rather than the committed files’ content (and size), are not included in the hash calculation.

### History

```
git log --pretty=oneline --graph --decorate
git log --pretty=format:"%h - %an : %s" --graph --decorate
```

### Branch

```
git branch [branch-name]                                  # creating a branch
git branch -vv                                            # list branch
git checkout [branch-name]                                # switching branchs
git branch --set-upstream-to=[remote-name]/[branch-name]  # track remote branch
git push origin --delete [branch-name]                    # delete remote branch
```

### Merge

##### Knowing in advance which version to stay with

It may happen that we know beforehand which version we want to choose in case of conflicts. In these cases, we can tell Git which version use, to make it apply it directly.

To do this, we have to pass the -X option to merge, indicating which version use:

```
git merge -X [ours|theirs] [branch-name]
```

So, for using HEAD version, we would have to use ours option; instead, for using the version that is not HEAD’s, theirs has to be passed.

##### Avoid using fast-forward mode

When we are merging branches, is always advisable not to use the fast-forward mode. This is achieved passing --noff flag while merging, since the history is reflected as it is actually is. The no fast-forward mode should be always used.

```
git merge --no-ff branch-name
```

### Diff

##### Differences between working-directory and staged

```
git diff
```

##### Differences between staged and last-commited

```
git diff -staged
```

##### Differences between exact points in history

```
git diff [original]..[modified] # hashcode/branch-name/HEAD/tags
```

### Tag

```
git tag                                   # listing tags
git tag -a [tag-name] -m "comment"        # creating an annotated tag
git show [tag-name]                       # show tag
git checkout -b [branch-name] [tag-name]  # checkout tags
```

### Undoing

##### Removing files

To remove a file from Git, you have to remove it from your staging area and then commit.

If you remove a modified file, you must force the removal with the -f option. This is a safety feature to prevent accidental removal of data that hasn’t yet been recorded in a snapshot and that can’t be recovered from Git.

```
git rm [file]
```

Another useful thing you may want to do is to keep the file in your working tree but remove it from your staging area. In other words, you may want to keep the file on your hard drive but not have Git track it anymore.

```
git rm --cached [file]
```

##### Moving files

```
git mv [file-from] [file-to]
```

##### Modifying the last commit

```
git add forgotten_file
git commit --amend -m "comment"
```

##### Discard changes in working directory

```
git checkout [file]
```

##### Unstaging a Staged File

```
git reset HEAD [file]
```

##### Deleting commits

That is, if you make a soft reset, the commit(s) will be removed, but the modifications saved in that/those commit(s) will remain; and a hard reset, won't leave change made in the commit(s). If no flag is specified, the reset will be done softly.

```
git reset [--hard|--soft] HEAD^   # First parent of the current branch
git reset [--hard|--soft] HEAD~n  
```

### Remote repositories

##### Add a remote

```
git remote add [remote-name] [repo-url] # origin as default remote-name
```

##### Showing Your Remotes

```
git remote -v
git remote show [remote-name]
```

##### Fetch: updating remote references

Updated the reference to remote’s branch, but the changes have not been applied in the repository

```
git fetch [remote-name] [branch-name]
```

What has Git internally with this? Well, now, a directory .git/refs/remotes has been created, and, inside it, another directory, origin (because that’s the name we have given to the remote). Here, Git creates a file for each branch exiting in the remote repository, with a reference to it. This reference is just the SHA1 id of the last commit of the given branch of the remote repository. This is used by Git to know if in remote repo are any changes that can be applied to the local repository.

Merge the remote branch, which has just been updated; with the local branch.

```
git merge [remote-name]/[branch-name] # no fast-forward merge
```

##### Pull: fetching and merging remotes at once

```
git pull [remote-name] [branch-name]
```

##### Push: writing changes into the remote

```
git push [remote-name] --all                   # Updates the remote with all the local branches
git push [remote-name] [branch-name]           # Updates remote’s mater and dev branches
git push [remote-name] [tag-name]              # push tag
git push [remote-name] --tags                  # Sends tags to remotes
git push [remote-name] --delete [branch-name]  # delete remote branch
```

##### Clone a repository

```
git clone [repo-url]
```

By default, when cloning a repository, only the default branch is created (master, generally). The way to create the other branches locally is making a checkout to them.

Remote branches can be shown with branch option with -r flag:

```
git branch -r
```

##### Deleting things in remote repository

```
git push [remote-name] :[branch-name]      # deleting branches, push nothing
git push [remote-name] --tags :[tag-name]  # deleting tags, push nothing
```

# Patches

A patch is just a file that describes the changes that have to be made over a program, indicating which code lines have to be removed, and which have to be added. With Git, a path is just the output of a diff saved into a file.

Patches are thought for hotfixes, or also critical features that have to be fixed or implemented right now, not for being the common update and deploying strategy.

### Creating patches

As said, a patch for Git is just the output of a diff. So, we would have to redirect that output to a file:

```
git diff [original]..[modified] > [patch-name.patch] # hashcode/branch-name/HEAD/tags
```

A patch cannot be modified. If a patch file suffers any modification, Git will mark it as corrupt and it won’t apply it.

### Applying patches

```
git apply [--ignore-space-change | --ignore-whitespace] [--verbose] [patch-file]
```

If patching goes well, no message will be displayed (if you haven’t used the --verbose flag). If the patch is not applicable, Git will show which are the files causing problems.

Is quite common to get errors due to just whitespace differences. These errors can be ignored with --ignore-space-change and --ignore-whitespace flags.

# How to Init Git Flow

```
git init
git remote add origin [repo-url] # origin as default remote-name
git pull origin master
git branch --set-upstream-to=origim/master
git flow init -d

  Remote branch:
    master tracked
  Local branch configured for 'git pull':
    master merges with remote master
  Local ref configured for 'git push':
    master pushes to master (up to date)

```

# Resources

[Git Pro](https://git-scm.com/book/en/v2)

[Git Reference](https://git-scm.com/docs)

[Git Flow](https://github.com/nvie/gitflow)

[A successful git branching model](http://nvie.com/posts/a-successful-git-branching-model/#the-main-branches)
