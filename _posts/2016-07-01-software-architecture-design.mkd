---
layout: post
title:  "软件架构设计基础"
date:   2016-07-01 12:00:00
categories: architecture
---

* TOC
{:toc}

## 1 软件架构定义

架构 = 组件 + 组件之间的交互

## 2 软件架构设计驱动因素

$$
软件需求
  \begin{cases}
    功能需求 \\
    \\
    \\
    非功能需求
    \begin{cases}
      质量属性
      \begin{cases}
        运行期质量属性 \\
        开发期质量属性
      \end{cases}
      \\
      约束
    \end{cases}
  \end{cases}
$$

### 2.1 功能需求 - 关键功能

软件功能的完整实现，需要系统各模块间相互配合，形成一条“模块协作链”。功能需求相当于串起不同模块的“线索”。软件架构关键功能需求，是那些涉及模块最多，最典型的功能需求。

### 2.2 质量属性

$$
  质量属性
  \begin{cases}
    运行期质量属性
    \begin{cases}
      可用性(Availability) \\
      易用性(Usability) \\
      可靠性(Reliability) \\
      性能(Performance) \\
      安全性(Security) \\
      可伸缩性(Scalability)
    \end{cases}
    \\
    \\
    \\
    开发期质量属性
    \begin{cases}
    易理解性(Understandability) \\
    可扩展性(Extensibility) \\
    可重用性(Reusability) \\
    可测试性(Testability) \\
    可维护性(Maintainability) \\
    可移植性(Portability)
    \end{cases}
  \end{cases}
$$

<br/>
质量属性中最重要的是可维护性，有了可维护性，其他质量属性都可以在日后实现。
<br/>

$$\begin{align*}
Cost_{total} &= Cost_{develop} + Cost_{maintain} \\
Cost_{maintain} &>= Cost_{develop} \\
Cost_{maintain} &= Cost_{understand} + Cost_{change} + Cost_{test} + Cost_{depoly} \\
\end{align*}$$

### 2.3 约束

客户需求及业务相关约束：行业标准、政策法律。

用户及使用环境相关约束：用户特点、用户水平、早期版本使用习惯。

开发组织及开发环境相关约束：开发组织技术特点、开发组织分布、开发组织软件资产。

![architecture-design-driven-factor](/images/architecture/architecture-design-driven-factor.png)

## 3 架构视图

架构视图是对于从某一视角或某一点上看到的系统所做的简化描述，描述中涵盖了系统的某一特性方面，而省略了与此方面无关的实体。多视图的软件架构是软件架构设计文档中的重要组成部分。它不仅是一种架构归档的方法，更是一种架构设计的思维方法。

### 3.1 RUP 4+1视图

![rup](/images/architecture/rup.png)

#### 3.1.1 场景视图

作为驱动因素来发现架构设计过程中的架构元素、且作为架构设计结束后的验证，用例图确定与本系统交互的角色或外部系统，描述系统必须提供的功能，界定系统的范围。

#### 3.1.2 逻辑视图

重点考虑功能需求，將系統分解成一系列功能抽象，关注功能抽象集、及相互之间的关系。使用组件图、类图来描述静态逻辑视图，使用顺序图、活动图来描述动态逻辑视图。

#### 3.1.3 物理视图

描述系统赖以运行的计算机、网络、硬件设施等环境、以及如何将软件包部署到这些硬件资源上。

#### 3.1.4 运行视图

描述系统的并发（多实例/进程/线程）和同步（同步函数调用/异步消息通信）方面的设计。

#### 3.1.5 开发视图

应当为开发人员提供切实的指导。其中采用哪些现成框架、哪些第三方SDK、哪些中间件平台，都应该由开发视图确定下来。

### 3.2 架构设计的五视图法

![architecture-view](/images/architecture/architecture-view.png)

### 3.3 架构设计内容

* 架构目标 : 简要描述架构设计要达到的高层商业目标或要解决的关键问题

* 架构需求 : 描述对架构有重大影响的需求（功能需求和质量属性需求）

* 假设和约束 : 包括环境特征、多语言支持、软硬件约束、遵守的标准等

* 领域架构 : 描述产品架构对相应领域架构的遵从情况，及与领域架构的差异点

* 逻辑视图 : 分层描述组成系统的功能模块及功能模块之间的接口。描述模块之间的动态交互，以验证关键功能需求实现

* 开发视图 : 描述逻辑模块与开发交付件（代码、脚本）的对应关系，软件包结构，以及采用的框架与库

* 运行视图 : 描述模块到系统运行单元（进程、线程）的对应方案

* 物理视图 : 描述模块到物理节点（服务器、单板）的部署方案、包括组网、存储等方案

* 质量属性设计 : 逐一描述关键质量属性的设计方案，权衡决策理由

### 3.4 软件架构模式

![architecture-design-pattern](/images/architecture/architecture-design-pattern.png)

* Layers 分层模式 : 根据不同抽象层次划分应用程序功能

* Domain Object 领域对象模式 : 在同一抽象层次内，划分并模块化应用程序功能  

* Publisher-Subscriber 发布订阅模式 : 通过单向变更传播机制来实现组件之间的交互  

* Explicit Interface 明确接口模式 : 为领域对象的功能提供良好定义的访问接口

* Encapsulated Implementation 封装实现模式 : 提供并封装领域对象的实现

* Broker 代理者模式 : 分布式系统中的组件通过远程过程调用实现业务交互

* Messaging 消息发布模式 : 分布式系统中的组件通过消息交换实现业务交互

* Pipes and Filters 管道过滤器模式 : 分解数据流处理系统成多个过滤器、通过管道连接过滤器

* Model-View-Controller 模型视图控制器模式 : 将应用程序功能与它的表示和控制相分离

* Reflection 反射模式 : 提供一种动态更改软件系统结构和行为的机制

* Template View 模板视图模式 : 提供一种让软件适应不用语言变化的机制

* Component Configuration 组件配置器模式 : 让应用程序能够对可重用组件进行动态配置

## 4 架构设计原则

### 4.1 架构设计总体原则

#### 4.1.1 领域视角原则

架构师和系统工程师必须要有领域工程意识，必须站在领域的角度，从多产品、多版本应用构成的领域维度来规划和设计架构。

#### 4.1.2 系统视角原则

架构师和系统工程师必须要有系统工程意识，架构设计必须站在全系统的角度，对整个系统进行宏观整体把握，不能把软件/硬件割裂开来，只考虑某一个方面。另一方面，系统设计中各个方面的能力是均衡的，没有明显的瓶颈和短木板。

#### 4.1.3 重用原则

重用分为几个层次：架构重用、组件重用、设计重用、代码重用。领域架构设计强调的是领域内架构的重用和基于架构的组件重用。架构重用包括：逻辑架构重用和物理架构重用，在可能的情况下尽量扩大重用的范围。产品进行系统设计和实现时必须遵循重用原则，产品应用开发时，如果已有领域架构和平台，则其系统设计必须符合领域架构，并应用平台组件开发；如果无领域架构和平台，则需要考虑如何构建领域架构和平台为后续类似产品的重用和共享做好准备。

#### 4.1.4 商业目标原则

由于影响架构设计的各个质量属性之间存在一定的联系和冲突，比如：高的性能需求会导致成本的上升，高的可靠性要求也会导致成本的上升，扩展性的提高可能会牺牲一定的性能，而可移植性好则会提升架构的可重用性等等。因此架构设计时必须对各个质量属性进行权衡，而权衡的依据就是架构设计的商业目标，包括：目标市场、架构的应用范围、上市时间、成本和收益、生命周期、与老系统的集成、关键需求、质量属性需求、开发过程和约束等，只有确定了商业目标才能确定架构设计的方向并对各个相互冲突的质量属性进行仲裁和权衡。一般来说，领域架构强调的是重用，因此可重用性是领域架构设计的关键，一切设计都要围绕着重用进行设计，因而可能会牺牲一定的性能。

#### 4.1.5 一致性原则

架构设计应该作为一个统一的整体而存在，架构设计在整体上应该是统一、和谐的，符合美学原则。架构中类似需求应该遵循相同的设计规范和标准，比如：接口等。架构中类似的处理机制应该是统一的：如故障处理流程。而可测试性、可调试性等设计等都应该采用统一的框架设计和实现。

#### 4.1.6 够用/简单原则

在达到预定的目标、具备所需要的功能前提下，架构设计应尽量简单，避免“过度设计”，这样可减少处理费用，提高系统效益，便于实现和管理。简化组件/模块/方法/类的功能设计，避免设计面面俱到的多功能组件/模块/方法/类；调用功能时，避免功能过剩。高水平的架构设计师高就高在“设计出恰好能满足客户需求的架构，并且使开发方和客户方”获得最大的利益，而不是不惜代价设计出最先进、最全面的架构。因此，架构设计应该在适当的范围内考虑其可扩展性，特别需要杜绝为了应用某种新技术而采用新的架构。抽象层次越高的逻辑架构适用范围会广些，在较长的时间里稳定较高，但对单个产品的设计开发投入要求会较高一些；抽象层次较低的逻辑架构，适用范围相对窄些、稳定度要低一些，但对单个适用的产品的设计开发投入要求要低一些。通常在不同的产品或者领域层次存在不同抽象层次的逻辑架构。

#### 4.1.7 变化点分离原则

领域架构设计的核心就是通过设计支持各个变化点独立变化，因此在需求分析阶段就需要分离公共的部分和变化部分，判断出哪些需求是相对稳定不变的，哪些需求是可能变化的，并将不同的变化点分离开；在逻辑架构设计时，工作重点也是使变化点在逻辑上隔离，并确定支持变化点的机制。根据那些稳定不变的需求设计体系结构，而根据那些可变的需求设计软件的“可扩展性”。分面和分层都是识别并隔离变化点的方法，使得架构具有良好的可扩展性。首先要确认软件中变和不变的因素，并根据变化频度进行分类。依据变化频度的分类进行层次划分，并标出各个层次的依赖关系。对不变的部分，设计的稳固、牢靠。对变化的部分，根据变化的频度设计其灵活性。分层模式的核心就是变化点分离原则，即按照变化的难易程度将结构分割成不同层次，位于最底部的是最稳固、最难以改变的结构，越往上就是稳固性越低、变化越容易的结构。

#### 4.1.8 逻辑与物理分离原则

系统功能逻辑与基于质量、成本等因素分割的物理实现并不存在直接的对应关系，同样的系统可能由于硬件技术和软件技术的需要，在功能部署和实现手段都会发生变化。架构设计强调多视角的设计，逻辑和物理分离就是在变化点分离原则的基础上，把逻辑功能和物理实现进行分离，在接口设计上就是把逻辑语义和接口形式以及物理承载分离开。逻辑架构是逻辑功能划分，领域的逻辑架构就是领域架构(DSSA)，这就是说逻辑架构是领域内系统的公共架构，即架构能够在领域内重用。而物理架构反映了设计元素(DM)或实现元素(IM)的物理分布，以及运行时刻组件之间的关系。与物理架构对应的UML模型是部署模型。

#### 4.1.9 支持分阶段交付原则

目前大型通信系统，其需求和规模是非常大的，它的实现一般都要分期分步进行，架构设计要能够支持平台和产品分阶段/增量式实现和交付的要求，具有较强的可修改性和可扩展性。分阶段交付的版本之间要保持兼容性。

### 4.2 平面/层次/子系统/模块划分原则

#### 4.2.1 高内聚/低耦合原则

子系统/模块的划分必须具有独立性，将联系比较密切、功能近似的部分集中，使得子系统/模块的内部功能、信息等各个方面的凝聚性较好。子系统/模块之间的联系要尽量减少，接口设计简单、明确，尽量减少子系统/模块相互之间各种不必要的数据、调用和控制联系。一个内部联系强的子系统/模块对外部的联系必然是相对很少的。

#### 4.2.2 数据冗余最小原则

架构设计应该使得系统中的数据冗余最小，否则可能引起相关的功能数据分布在各个不同的子系统/模块中，大量的原始数据需要调用和同步，大量的中间结果需要保存和传递，大量计算工作将要重复进行。数据冗余使得程序结构紊乱，不但给软件开发工作带来很大的困难，而且系统的工作效率和可靠性也大大降低了。

#### 4.2.3 数据一致性原则

为了提高系统性能，备份节点和子系统/模块必要时需要对数据进行缓存，当发生变化时，必须有相应的机制保证缓存数据的一致性和有效性。

#### 4.2.3 通用平面划分原则

划分平面是隔离架构中变化点的常用方法。平面划分作为最高层次的系统划分，目的首先自然是进行功能的分类、分解，以及对系统复杂性分解、封装。平面划分的另一个目的是对系统设计所涉及知识领域的划分，或者说是工作的划分，便于让不同知识领域的专家专心于自己的领域开展下一步的设计工作。如果我们把系统看成一个指令执行系统和数据加工系统，即系统接收指令--执行--必要时向其他系统输出指令，或者接收数据--加工--输出加工后的数据。那么一个平面一般要求能够完成某个数据流（指令或数据）的整个过程。所以，一个平面的边界一定包含了系统的部分外界边界。从系统外部来看，不同的平面为不同的外部参与者提供不同的功能，即处理输入，同时负责输出。所以说，某一类外部事件或数据的处理过程都基本落在某一个平面内。 平面之间也会有交互，但这个交互过程通常只是一个执行命令或事件通知，处于主流程之外。所以平面之间应该是松耦合的。通常我们根据系统的数据流（指令或数据）的分类划分平面。在大型分布式系统中，系统中往往存在几类不同的数据流。不同之处不在于数据流的格式，而在于流量、QoS要求。通常，一个电信系统可以分为控制平面、业务平面（用户平面或数据平面）、转发平面和管理平面（或维护平面）等。下表显示了这三个平面数据流之间的一般差异。这些差异导致的后果就是在设计中需要对这些需求有不同的侧重和权衡。平面划分的结果是将不同类型的设计复杂性分在不同的平面内，这样我们就可以在不同的平面范围内相对独立地进行设计和权衡分析。通信设备的功能时类似的，可以采用类似的平面划分模式。一般来说，至少应该划出维护平面、控制平面和用户平面三大平面。

#### 4.2.4 通用的层次划分原则

划分层次也是隔离架构设计中变化点的常用方法。分层的目的是要实现可重用性、可更改性和可移植性。层次结构是一种应用非常广的架构模式。操作系统、数据库管理系统和网络通信软件都是层次结构软件系统的例子。对于追求屏蔽作用（屏蔽变化）的系统，首先需要把通用的部分和可变的部分分开。当通用部分和可变部分无法简单划分时，就需要一个抽象分析的过程。越是抽象的东西越不容易发生变化，越是具体的东西越是容易变化。抽象的结果可能不止两层，有时还需要在中间增加一层。

#### 4.2.5 分层的单向依赖原则

采用分层模式时，原则上只允许较高层次依赖于较低层次，不允许出现反向依赖。在某些特定情况下为了提高效率，较低层次也可依赖较高层次模块的信息和调度。

#### 4.2.6 无循环依赖原则

架构设计中，子系统/模块之间的依赖关系要尽量减少，且不允许模块之间出现循环依赖。

#### 4.2.7 避免跨层通信原则

采用分层模式时，原则上不允许出现跨层通信，包括：API调用、消息通信等。

#### 4.2.8 解耦原则

解耦原则要求架构设计中的各个DM之间是松耦合的，并且各个组件可以基于架构独立应用，这也是架构可裁剪性的实现基础。耦合是相互交互的系统彼此间的依赖。这种依赖又分为“真依赖”和“假依赖”。“真依赖”是系统从其他系统获取的特性和服务的集合，真依赖总是存在的，无法简化。“假依赖”是系统为获得其他系统的提供的特性或服务而不得不服从的要素，典型的“假依赖”包括语言依赖、平台依赖、API依赖等，假依赖总是存在的，但是可以减少的。理想状态的松耦合体现在系统间仅存在真依赖关系，但现实中的松耦合为假依赖的最小化。

#### 4.2.9 实现无关性原则

构成架构的元素DM是与实现无关的，这也正是架构能够重用的关键。

#### 4.2.10 灵活部署原则

架构设计要能够支持各模块灵活部署。构成架构的元素DM的粒度划分需要考虑不同应用场景的部署需求，同时DM也是与实现无关的，其部署可以是灵活的，与物理位置无关。

### 4.3 接口设计原则

#### 4.3.1 接口标准化原则

架构设计中，模块之间的接口设计应该尽量采用业界标准协议和公司内部协议规范，以保持稳定性和兼容性。如果涉及对外的互操作，则建议采用业界标准协议。

#### 4.3.2 接口扩展性原则

接口设计要具有良好的可扩展性。比如通过预留字段等方式以便今后的扩展。

#### 4.3.3 接口兼容性原则

系列化接口中所有版本应该保持兼容性，其基础通用功能和关键特性接口（软件升级）设计在一个系列版本之内必须保持兼容。

#### 4.3.4 接口抽象性原则

接口设计要具有抽象性，接口定义应该强调接口的逻辑语义而不是实现方法，以屏蔽掉具体实现的差异。定义清楚逻辑功能模块的行为和接口的操作是需要的，但不应该规定与实现技术有关的细节，过于细节的定义会掩盖接口的操作语义本质，且会限制实现架构的重用。接口参数不能体现具体的实现细节。

### 4.4 质量属性设计原则

#### 4.4.1 可重用性原则

架构或基于此架构的某些组件能够在未来的产品应用开发中能够重复使用。这要求架构设计时要充分分析其应用场景、范围和实现技术、以及不同的质量属性。

#### 4.4.2 可扩展性原则

可扩展性是通过变更系统增加新功能的能力和容易程度，架构设计根据其规模和复杂性对可扩展性有不同的要求。较强的可扩展性也是实现“分阶段开发和交付”的一个要求，架构的稳定性是根据那些稳定不变的需求而设计的，架构的可扩展性则是依据那些可变的需求而设计的。稳定性和可扩展性之间存在辩证的关系：如果架构不可扩展的话，那么就没有发展前途，所以不能只关心稳定性而忽视可扩展性；“可扩展”的前提条件是“保持架构稳定”，稳定性是使系统能够持续发展的基础。

#### 4.4.3 可修改性原则

基于该架构产品及平台的可修改性，是与系统架构关系最为密切的一个质量属性。基于架构的产品能够进行快速修改，修改代价低，架构不限制组件设计及局部设计的修改。对外接口稳定，对内接口：机制稳定、可演进、可扩充。领域架构本身具有自我扩展性。分层是一种通用的可修改性实现方法，通过分层，可以使得修改被限制在各层之内，各层的修改不会影响其他层次的设计和实现。

#### 4.4.4 可移植性原则

架构设计不依赖于特定的运行环境，基于架构的产品及平台具有能够在不同软件或硬件环境下运行的能力。如果对任何特定运行环境的所有假设都仅包含其中一个组件（或者在最坏情况下，包含在少数几个易于修改的组件）中，则该架构是可移植的。一般通过分层模式来提高架构的可移植性，在架构中对平台相关实现细节的封装表现为可移植性层，比如硬件抽象层。

#### 4.4.5 兼容性原则

架构设计上要支持不同应用场景以及系列化版本之间的兼容性设计。兼容性有两个方面的含义：一是版本的前向和后向兼容，另一个是对运行环境的兼容性。运行环境包括软件环境（如OS）、硬件环境（如硬件平台）和网络环境（如接口兼容性）等，运行环境的兼容性要求与可移植性要求是相同的。后向兼容是兼容老版本，前向兼容是指将来可以被新版本所兼容，所以前向兼容本质上是特殊的可扩展性需求。

#### 4.4.6 可伸缩性原则

架构设计在不同的应用场景下具有一定的可伸缩性，包括容量、规格等指标。在线扩容能力就是一种可伸缩性，当用户增长时，可以通过增加服务器来适应。

#### 4.4.7 可裁剪性原则

可裁剪性是指用户从系统中删除部分功能的难易程度，或者从系统中选择部分功能丢弃其他功能的难易程度。可裁剪性有利于提高架构的可重用性。架构和平台设计必须具有良好的可裁剪性，可裁剪性可以看成是可配置性的一个方面。可裁剪性设计要求尽量降低组件之间的耦合和依赖关系。

#### 4.4.8 性能原则

架构设计必须满足预定的性能目标，做好性能、成本、可扩展性和可移植性等的综合权衡，并能够根据应用场景的变化具有平滑扩容的能力。性能需求主要包括两个方面，一是吞吐量，指系统或部件在指定时间内执行的工作量，二是响应时间或速度，指事务或请求与响应之间的平均延迟。例如：支持1万用户同时发起请求，这是系统的吞吐能力。平均请求时间为0.5秒，这是响应时间。系统性能还包括：容量，比如可以允许100万注册用户；资源占用率，如内存资源的使用效率，CPU资源占用率；在物理架构部署时可能因为性能的需要把不同的逻辑功能模块部署到同一个物理实体上实现，这样有利于逻辑功能模块之间的通信效率。为了提高处理能力，也可以根据需要使用硬件来替代原来的软件实现的功能。

#### 4.4.9 可用性/可靠性原则

架构设计要满足预定的可靠性/可用性指标。不用的应用场景对可靠性指标的要求是不同的。系统的可靠性指系统硬件和软件在运行过程中抵抗异常情况的干扰及保证系统正常工作的能力。衡量系统可靠性的指标是平均故障间隔时间和平均维护时间。前者指平均的前后两次发生故障的时间，反映了系统安全运行时间，后者指故障发生后平均每次所用的修复时间，反映系统可维护性的好坏。只有可靠的系统，才能保证系统的质量并且得到用户的信任，否则就是没有使用价值。架构设计上提高系统可靠性的途径主要有：冗余设计：既在高可靠性的应用场合，应采用双机或双工的结构方案。资源池设计/负荷分担：通过共享资源/负荷分担来提高系统可靠性。多平面/多通道设计：对不同可靠性和Qos要求数据进行区分并分别设计数据平面/通道，避免相互影响，并在承载平面/通道发生故障时可以切换到其他平面/通道。设计安全机制：容错机制、资源核查、故障检测和自愈自恢复设计等。

#### 4.4.10 安全性原则

架构设计必须满足目标应用场景的安全需求。安全性是衡量系统在向合法用户提供服务的同时，阻止非授权用户使用的能力，以及防止意外或恶意访问限制性的资源或大量的资源，试图显示数据、改变/删除数据、访问系统服务、降低系统的可用性。

#### 4.4.11 可测试性/可调试性原则

架构设计必须具有良好的可测试性/可调试性。良好的可测试性/可调试性能够方便系统缺陷的发现，并且在发现问题后能够快速检测和定位故障。设计中应该统一考虑可测试性/可调试性框架的设计和实现，尽量减少测试软件和产品软件之间的耦合性。

#### 4.4.12 可安装性原则

可安装性是指完成系统安装的难易程度。架构上可以通过减少模块种类、减少接口种类和数量、合理调整物理架构的功能模块部署等方法来提高系统可安装性。

#### 4.4.13 可配置性原则

架构设计上提供，能够方便地支持组件的裁剪和配置。可配置性是指用户或维护人员在不对系统进行实质性修改的情况下，而是通过修改系统的宏定义、参数，或输入指令等手段来改变系统运行时的行为。用户能够制定自己喜欢的界面风格，二次开发人员根据模块的消息流量配置消息队列缓存区大小、维护人员通过网管系统配置参数，系统提供方根据买卖合同使用license提供的功能定制系统，产品中隐含的那些那些只有厂家的技术人员或开发人员才能执行的配置功能等等都是可配置性需求。可配置性需求支撑了系统可维护性需求，比如允系统增加新的部件。但是可配置性需求同时也能服务于其他一些特性，比如配置接口协议参数是为互操作性服务的。所以说，可配置性与可维护性是不同的质量属性，只是具体的需求可能会同时与这两种属性相关，即一个可维护性需求可能会衍生出可配置性需求。

#### 4.4.14 易懂性原则

好的架构设计必然是易于理解，易于掌握的，同时符合自然原则和美学原理。 良好的易懂性同时也有利于提高系统的可维护性。

#### 4.4.15 可维护性原则

可维护性是指进行系统维护的难易程度和维护成本的高低，包括问题定位的难易程度、准确性、修改的方便性。
