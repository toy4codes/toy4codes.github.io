---
layout: post
title:  "JVM"
date:   2017-07-03 12:00:00
categories: jvm
---

# Performance Basics

Typically, when tuning a Java application, the focus is on one of two main goals: responsiveness or throughput.

### Responsiveness

Responsiveness refers to how quickly an application or system responds with a requested piece of data. For applications that focus on responsiveness, large pause times are not acceptable. The focus is on responding in short periods of time.

### Throughput

Throughput focuses on maximizing the amount of work by an application in a specific period of time. High pause times are acceptable for applications that focus on throughput. Since high throughput applications focus on benchmarks over longer periods of time, quick response time is not a consideration.

# Class Loader Subsystem

![Class Loader Subsystem](/images/jvm/Class Loader Subsystem.png)

# Runtime Data Area

![Runtime Data Area](/images/jvm/Runtime Data Area.png)

# JVM Memory Management

![JVM Memory Management](/images/jvm/JVM Memory Management.png)

The **Young Generation** is where all new objects are allocated and aged. When the young generation fills up, this causes ***a minor garbage collection***. Minor collections can be optimized assuming a high object dead rate. A young generation full of dead objects is collected very quickly. Some surviving objects are aged and eventually move to the old generation.

**Stop the World Event** - All minor garbage collections are "Stop the World" events. This means that all application threads are stopped until the operation completes. Minor garbage collections are always Stop the World events.

The **Old Generation** is used to store long surviving objects. Typically, a threshold is set for young generation object and when that age is met, the object gets moved to the old generation. Eventually the old generation needs to be collected. This event is called ***a major garbage collection***.

Major garbage collection are also Stop the World events. Often a major collection is much slower because it involves all live objects. So for Responsive applications, major garbage collections should be minimized. Also note, that the length of the Stop the World event for a major garbage collection is affected by the kind of garbage collector that is used for the old generation space.

The **Permanent generation** contains metadata required by the JVM to describe the classes and methods used in the application. The permanent generation is populated by the JVM at runtime based on classes in use by the application. In addition, Java SE library classes and methods may be stored here.

Classes may get collected (unloaded) if the JVM finds they are no longer needed and space may be needed for other classes. The permanent generation is included in ***a full garbage collection***.

# Reachability Analysis

![Reachability Analysis](/images/jvm/Reachability Analysis.png)

# Garbage Collection Algorithm

![Garbage Collection Algorithm](/images/jvm/Garbage Collection Algorithm.png)

# Garbage Collectors

![Garbage Collectors](/images/jvm/Garbage Collectors.png)

### -XX:+UseSerialGC

Enables the use of the serial garbage collector. This is generally the best choice for small and simple applications that do not require any special functionality from garbage collection. By default, this option is disabled and the collector is chosen automatically based on the configuration of the machine and type of the JVM.

### -XX:+UseParNewGC

Enables the use of parallel threads for collection in the young generation. By default, this option is disabled. It is automatically enabled when you set the -XX:+UseConcMarkSweepGC option. Using the -XX:+UseParNewGC option without the -XX:+UseConcMarkSweepGC option was deprecated in JDK 8.

### -XX:+UseParallelGC

Enables the use of the parallel scavenge garbage collector (also known as the throughput collector) to improve the performance of your application by leveraging multiple processors. By default, this option is disabled and the collector is chosen automatically based on the configuration of the machine and type of the JVM. If it is enabled, then the -XX:+UseParallelOldGC option is automatically enabled, unless you explicitly disable it.

### -XX:+UseParallelOldGC

Enables the use of the parallel garbage collector for full GCs. By default, this option is disabled. Enabling it automatically enables the -XX:+UseParallelGC option.

### -XX:+UseConcMarkSweepGC

Enables the use of the CMS garbage collector for the old generation. Oracle recommends that you use the CMS garbage collector when application latency requirements cannot be met by the throughput (-XX:+UseParallelGC) garbage collector. The G1 garbage collector (-XX:+UseG1GC) is another alternative. By default, this option is disabled and the collector is chosen automatically based on the configuration of the machine and type of the JVM. When this option is enabled, the -XX:+UseParNewGC option is automatically set and you should not disable it, because the following combination of options has been deprecated in JDK 8: -XX:+UseConcMarkSweepGC -XX:-UseParNewGC.

### -XX:+UseG1GC

Enables the use of the garbage-first (G1) garbage collector. It is a server-style garbage collector, targeted for multiprocessor machines with a large amount of RAM. It meets GC pause time goals with high probability, while maintaining good throughput. The G1 collector is recommended for applications requiring large heaps (sizes of around 6 GB or larger) with limited GC latency requirements (stable and predictable pause time below 0.5 seconds). By default, this option is disabled and the collector is chosen automatically based on the configuration of the machine and type of the JVM.

# CMS Garbage Collector

![Serial Parallel CMS](/images/jvm/Serial Parallel CMS.png)

The Concurrent Mark Sweep collector collects the tenured generation. It attempts to minimize the pauses due to garbage collection by doing most of the garbage collection work concurrently with the application threads. **The CMS does not compact the live objects unless there is a full GC**.

> CMS collector on young generation uses the same algorithm as that of the parallel collector.

# G1 Garbage Collector

![G1 Heap Allocation](/images/jvm/G1 Heap Allocation.png)

The Garbage-First (G1) collector is a server-style garbage collector, targeted for multi-processor machines with large memories. It meets garbage collection (GC) pause time goals with a high probability, while achieving high throughput.

G1 is planned as the long term replacement for the Concurrent Mark-Sweep Collector (CMS). Comparing G1 with CMS, there are differences that make G1 a better solution. One difference is that G1 is a compacting collector. G1 compacts sufficiently to completely avoid the use of fine-grained free lists for allocation, and instead relies on regions. This considerably simplifies parts of the collector, and mostly eliminates potential fragmentation issues. Also, G1 offers more predictable garbage collection pauses than the CMS collector, and allows users to specify desired pause targets.

G1 has both concurrent (runs along with application threads) and parallel (multi-threaded, e.g., stop the world) phases. Full garbage collections are still single threaded, **but if tuned properly your applications should avoid full GCs**.

### Recommended Use Cases

The focus of G1 is to provide a solution for users running applications that require large heaps with limited GC latency. This means heap sizes of around 6GB or larger, and stable and predictable pause time below 0.5 seconds.

Applications running today with either the CMS or the ParallelOldGC garbage collector would benefit switching to G1 if the application has one or more of the following traits.

* Full GC durations are too long or too frequent.
* Undesired long garbage collection or compaction pauses (longer than 0.5 to 1 second)

### Best Practices

##### Do not Set Young Generation Size

Explicitly setting young generation size meddles with the default behavior of the G1 collector.

* G1 will no longer respect the pause time target for collections. So in essence, setting the young generation size disables the pause time goal. 
* G1 is no longer able to expand and contract the young generation space as needed. Since the size is fixed, no changes can be made to the size. 

##### Response Time Metrics

Instead of using average response time (ART) as a metric to set the **XX:MaxGCPauseMillis**, consider setting value that will meet the goal 90% of the time or more. This means 90% of users making a request will not experience a response time higher than the goal. Remember, the pause time is a goal and is not guaranteed to always be met. 

##### Expensive Evacuation Failure

A promotion failure that happens when a JVM runs out of heap regions during the GC for either survivors and promoted objects. The heap can't expand because it is already at max. This is indicated in the GC logs when using XX:+PrintGCDetails by **to-space overflow**.

##### How to avoid Evacuation Failure

* Increase the -XX:G1ReservePercent, the default is 10.
* Increase the number of marking threads using the -XX:ConcGCThreads option.

### G1 GC Options

##### -XX:MaxGCPauseMillis=time

Sets a target for the maximum GC pause time (in milliseconds). This is a soft goal, and the JVM will make its best effort to achieve it. By default, there is no maximum pause time value.

The following example shows how to set the maximum target pause time to 500 ms:

```
-XX:MaxGCPauseMillis=500
```

##### -XX:InitiatingHeapOccupancyPercent=percent

Sets the percentage of the heap occupancy (0 to 100) at which to start a concurrent GC cycle. It is used by garbage collectors that trigger a concurrent GC cycle based on the occupancy of the entire heap, not just one of the generations.

By default, the initiating value is set to 45%. A value of 0 implies nonstop GC cycles. The following example shows how to set the initiating heap occupancy to 75%:

```
-XX:InitiatingHeapOccupancyPercent=75
```

##### -XX:NewRatio=ratio

Sets the ratio between young and old generation sizes. By default, this option is set to 2. The following example shows how to set the old/young ratio to 1:

```
-XX:NewRatio=1
```

##### -XX:SurvivorRatio=ratio

Sets the ratio between eden space size and survivor space size. By default, this option is set to 8. The following example shows how to set the eden/survivor space ratio to 4:

```
-XX:SurvivorRatio=4
```

##### -XX:MaxTenuringThreshold=threshold

Sets the maximum value for tenuring threshold. The largest value is 15. The default value is 15 for the parallel (throughput) collector, and 6 for the CMS collector.

The following example shows how to set the maximum tenuring threshold to 10:

```
-XX:MaxTenuringThreshold=10
```

##### -XX:ParallelGCThreads=threads

Sets the number of threads used for parallel garbage collection in the young and old generations. The default value depends on the number of CPUs available to the JVM.

For example, to set the number of threads for parallel GC to 2, specify the following option:

```
-XX:ParallelGCThreads=2
```

##### -XX:ConcGCThreads=threads

Sets the number of threads used for concurrent GC. The default value depends on the number of CPUs available to the JVM.

For example, to set the number of threads for concurrent GC to 2, specify the following option:

```
-XX:ConcGCThreads=2
```

##### -XX:G1ReservePercent=percent

Sets the percentage of the heap (0 to 50) that is reserved to reduce the possibility of promotion failure for the G1 collector. By default, this option is set to 10%.

The following example shows how to set the reserved heap to 20%:

```
-XX:G1ReservePercent=20
```

##### -XX:G1HeapRegionSize=size

Sets the size of the regions into which the Java heap is subdivided when using the garbage-first (G1) collector. The value can be between 1 MB and 32 MB. The default region size is determined ergonomically based on the heap size.

The following example shows how to set the size of the subdivisions to 16 MB:

```
-XX:G1HeapRegionSize=16m
```

# Useful JVM Options

```
-XX:+HeapDumpOnOutOfMemoryError
-XX:+HeapDumpPath=heapdump.hprof
-XX:+PrintGCDetails 
-XX:+PrintGCDateStamps 
-XX:+PrintGCTimeStamps
-Xloggc:garbage-collection.log
```

# JVM Tools

jps : [https://docs.oracle.com/javase/8/docs/technotes/tools/unix/jps.html](https://docs.oracle.com/javase/8/docs/technotes/tools/unix/jps.html)

jinfo : [https://docs.oracle.com/javase/8/docs/technotes/tools/unix/jinfo.html](https://docs.oracle.com/javase/8/docs/technotes/tools/unix/jinfo.html)

jstat : [https://docs.oracle.com/javase/8/docs/technotes/tools/unix/jstat.html](https://docs.oracle.com/javase/8/docs/technotes/tools/unix/jstat.html)

jmap : [https://docs.oracle.com/javase/8/docs/technotes/tools/unix/jmap.html](https://docs.oracle.com/javase/8/docs/technotes/tools/unix/jmap.html)

jstack : [https://docs.oracle.com/javase/8/docs/technotes/tools/unix/jstack.html](https://docs.oracle.com/javase/8/docs/technotes/tools/unix/jstack.html)

# References

[Java Garbage Collection Basics](http://www.oracle.com/webfolder/technetwork/tutorials/obe/java/gc01/index.html)

[Getting Started with the G1 Garbage Collector](http://www.oracle.com/technetwork/tutorials/tutorials-1876574.html)

[Memory Management in the Java HotSpot VM](http://www.oracle.com/technetwork/java/javase/memorymanagement-whitepaper-150215.pdf)

[Java HotSpot VM Options](http://www.oracle.com/technetwork/java/javase/tech/vmoptions-jsp-140102.html)
