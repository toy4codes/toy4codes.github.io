---
layout: post
title:  "Git Basics"
date:   2017-05-20 12:00:00
categories: git-pro
---

#### Initializing a Repository in an Existing Directory

{% highlight java %}
$ git init
{% endhighlight %}

#### Cloning an Existing Repository

{% highlight java %}
$ git clone https://github.com/libgit2/libgit2
{% endhighlight %}

#### The lifecycle of the status of git files

![lifecycle.png](/images/lifecycle.png)

#### Checking the Status of Your Files

{% highlight java %}
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
nothing to commit, working directory clean
{% endhighlight %}

add a new file to your project, a simple README file. If the file didn’t exist before, and you run git status, you see your untracked file like so:

{% highlight java %}
$ echo 'My Project' > README
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Untracked files:
  (use "git add <file>..." to include in what will be committed)

    README

nothing added to commit but untracked files present (use "git add" to track)
{% endhighlight %}

#### Tracking Files

{% highlight java %}
$ git add README
{% endhighlight %}

If you run your status command again, you can see that your README file is now tracked and staged to be committed:

{% highlight java %}
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

    new file:   README
{% endhighlight %}

#### Staging Modified Files

Let’s change a file that was already tracked. If you change a previously tracked file called CONTRIBUTING.md and then run your git status command again, you get something that looks like this:

{% highlight java %}
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

    new file:   README

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

    modified:   CONTRIBUTING.md
{% endhighlight %}

Let’s run git add now to stage the CONTRIBUTING.md file, and then run git status again:

{% highlight java %}
$ git add CONTRIBUTING.md
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

    new file:   README
    modified:   CONTRIBUTING.md
{% endhighlight %}

At this point, suppose you remember one little change that you want to make in CONTRIBUTING.md before you commit it. You open it again and make that change, and you’re ready to commit. However, let’s run git status one more time:

{% highlight java %}
$ vim CONTRIBUTING.md
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

    new file:   README
    modified:   CONTRIBUTING.md

Changes not staged for commit:
  (use "git add <file>..." to update what will be committed)
  (use "git checkout -- <file>..." to discard changes in working directory)

    modified:   CONTRIBUTING.md
{% endhighlight %}

Now CONTRIBUTING.md is listed as both staged and unstaged. It turns out that Git stages a file exactly as it is when you run the git add command. If you commit now, the version of CONTRIBUTING.md as it was when you last ran the git add command is how it will go into the commit, not the version of the file as it looks in your working directory when you run git commit. If you modify a file after you run git add, you have to run git add again to stage the latest version of the file:

{% highlight java %}
$ git add CONTRIBUTING.md
$ git status
On branch master
Your branch is up-to-date with 'origin/master'.
Changes to be committed:
  (use "git reset HEAD <file>..." to unstage)

    new file:   README
    modified:   CONTRIBUTING.md
{% endhighlight %}

#### Short Status

{% highlight java %}
$ git status -s
 M README
MM Rakefile
A  lib/git.rb
M  lib/simplegit.rb
?? LICENSE.txt
{% endhighlight %}

New files that aren’t tracked have a ?? next to them

New files that have been added to the staging area have an A

Modified files have an M and so on. There are two columns to the output - the left-hand column indicates the status of the staging area and the right-hand column indicates the status of the working tree.

So for example in that output, the README file is modified in the working directory but not yet staged, while the lib/simplegit.rb file is modified and staged. The Rakefile was modified, staged and then modified again, so there are changes to it that are both staged and unstaged.








